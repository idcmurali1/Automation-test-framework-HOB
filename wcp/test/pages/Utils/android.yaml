functions:

  #--------------------------------------------------------------------------------------------------------------------

  # Description: This method set the platform before the start of the execution
  # Params       No params
  - name: functions.utils.hideKeyboard
    platform: android
    flow:
      - try:
          flow:
            - verifyKeyboard:
                shown: false
            - sleep:
                duration: 2000
          catch:
            flow:
              - goBack: true
      - log:
          message: "End function: utils.hideKeyboard"
          color: BLUE

  #--------------------------------------------------------------------------------------------------------------------

  # Description: This method set the platform before the start of the execution
  # Params       No params
  - name: functions.utils.getCartQuantity
    platform: android
    flow:
      - sleep:
          duration: 2000
      - getString:
          identifier: global.cartSummary
          attribute: text
          storeIn: cartQuantity
      - log:
          message: Current cart quantity ${cartQuantity}...
          color: CYAN
      - log:
          message: "End function: utils.hideKeyboard"
          color: BLUE

  #--------------------------------------------------------------------------------------------------------------------

  # Description: Taps Next button in the keyboard.
  # No Params
  - name: functions.utils.keyboard.tapNextBtn
    platform: android
    flow:
      - executeAppiumScript:
          method: "mobile: performEditorAction"
          params:
            - key: action
              value: next
      - log:
          message: "End function: functions.utils.keyboard.tapNextBtn"
          color: BLUE

  #-----------------------------------------------------------------------------------------------------------------

  # Description: This function select value from drop down
  # Params:      ${valueToSelect}  [Mandatory] Select the value from drop down.
  # Works for:   [ MX [✓]   MX-Bodega [✓]   US [__] ]
  - name: functions.utils.selectValueFromDropDown
    platform: android
    flow:
      - log:
          message: Select value from drop down - ${valueToSelect}.
          color: CYAN
      - if:
          identifier:
            notPresent:
              - identifier: utils.dropDown
          then:
            - scroll:
                direction: down
                untilIdentifier: utils.dropDown
                withinIdentifier: utils.dropDownContainer
                position: center
      - click:
          identifier: utils.dropDownValue
      - log:
          message: "End function: utils.selectValueFromDropDown"
          color: BLUE

  #-----------------------------------------------------------------------------------------------------------------

  # Description: This function get the pge title.
  # No Params
  # Works for:   [ MX [__]   MX-Bodega [__]   US [__]   CA [✓]]
  - name: functions.utils.getPageTitle
    platform: android
    flow:
      - getString:
          identifier: utils.pageTitle
          attribute: text
          storeIn: pageTitle
      - log:
          message: "End function: utils.selectValueFromDropDown"
          color: BLUE

#----------------------------------------------------------------------------------------------------------------------

  # DESCRIPTION: [Support Function] [Supports: functions.utils.json.CartFulfillmentGroupingBuilder.buildGroupsJson]
  #
  #              Initializes the variables that the CartFulfillmentGroupingBuilder uses to execute it's logic.
  #
  #              Initialized Variables:
  #                 - cartFulfillmentGrouping.processedGroups   (during the process, this var controls which groups were already processed in order not to repeat them)
  #                 - cartFulfillmentGrouping.processedProducts (during the process, this var controls which products were already processed in order not to repeat them)
  #                 - cartFulfillmentGrouping.currentGroup      (during the process, this var controls which group is being processed at the moment)
  #                 - cartFulfillmentGrouping.groupsJson        (this var will hold the built Json with the groups hierarchy)
  #
  - name: functions.utils.json.CartFulfillmentGroupingBuilder.initialize/support_function
    platform: android
    flow:
      - storeIn:
          key: cartFulfillmentGrouping.processedGroups
          value: '[]'
      - storeIn:
          key: cartFulfillmentGrouping.processedProducts
          value: '[]'
      - storeIn:
          key: cartFulfillmentGrouping.currentGroup
          value: ''
      - storeIn:
          key: cartFulfillmentGrouping.groupsJson
          value: '{"groups":[]}'
      - log:
          message: "End function: utils.json.CartFulfillmentGroupingBuilder.initialize/support_function"
          color: BLUE

#----------------------------------------------------------------------------------------------------------------------

  # DESCRIPTION: [Support Function] [Supports: functions.utils.json.CartFulfillmentGroupingBuilder.buildGroupsJson]
  #
  #              Stores a group with an empty products array in the Groups Json being built.
  #
  #              This function sets the control variable 'cartFulfillmentGrouping.currentGroup' with the given name
  #              for the process to be able to identify the group that is currently being processed.
  #
  #              Additionally, the group name is also stored in the control array 'cartFulfillmentGrouping.processedGroups'
  #              in order to be able to determine that a group element has already been processed when after the screen
  #              scrolling the same element is still present in the screen and the groups do not repeat in the Groups
  #              Json built.
  #
  #              Group Structure:
  #                 {
  #                     name: "",
  #                     products: []
  #                 }
  #
  # PARAMS:  ${groupName}  [Mandatory]  Name of the group to store in the built Groups Json.
  #
  - name: functions.utils.json.CartFulfillmentGroupingBuilder.storeGroup/support_function
    platform: android
    flow:
      # Check if group was processed already...
      - executeNode:
          file: wcp/test/helpers/arrayContains.js
          args:
            - value: ${cartFulfillmentGrouping.processedGroups} # (array)
            - value: ${groupName}                               # (searchValue)
          getResponse:
            storeIn: groupNameAlreadyProcessed

      # If group was not processed already...
      - if:
          condition: '!${groupNameAlreadyProcessed}'
          then:

            # Push it to processed groups...
            - executeNode:
                file: wcp/test/helpers/arrayPush.js
                args:
                  - value: ${cartFulfillmentGrouping.processedGroups} # (array)
                  - value: ${groupName}                               # (value)
                getResponse:
                  storeIn: cartFulfillmentGrouping.processedGroups

            # Set it as the current group...
            - storeIn:
                key: cartFulfillmentGrouping.currentGroup
                value: ${groupName}

            # Push it into the groups json with empty products array...
            - executeNode:
                file: wcp/test/helpers/CartPage/fulfillmentGroupingJsonTools-addGroup.js
                args:
                  - value: ${cartFulfillmentGrouping.groupsJson} # (groupsJson)
                  - value: ${groupName}                          # (groupName)
                getResponse:
                  storeIn: cartFulfillmentGrouping.groupsJson

            # Log push confirmation...
            - log:
                message: "Group Stored in groupsJson: '${groupName}'"
                color: CYAN

      - log:
          message: "End function: utils.json.CartFulfillmentGroupingBuilder.storeGroup/support_function"
          color: BLUE

#----------------------------------------------------------------------------------------------------------------------

  # DESCRIPTION: [Support Function] [Supports: functions.utils.json.CartFulfillmentGroupingBuilder.buildGroupsJson]
  #
  #              Stores a product with its name and price Groups Json being built in the current group being processed.
  #
  #              If the current group name obtained from the control variable 'cartFulfillmentGrouping.currentGroup' can't
  #              be determined, or is not already stored in the Groups Json being built, a group with the name
  #              'UNKNOWN_GROUP_NAME' will be created to store all elements in these categories.
  #
  #              Additionally, the product name is also stored in the control array 'cartFulfillmentGrouping.processedProducts'
  #              in order to be able to determine that a product element has already been processed when after the screen
  #              scrolling the same element is still present in the screen and the products do not repeat in the Groups
  #              Json built.
  #
  #              Product Structure:
  #                 {
  #                     name: "",
  #                     price: ""
  #                 }
  #
  # PARAMS:  ${productName}   [Mandatory]  Name of the product to store in the built Groups Json in the current Group Name.
  #          ${productPrice}  [Mandatory]  Price of the product to store in the built Groups Json in the current Group Name.
  #
  - name: functions.utils.json.CartFulfillmentGroupingBuilder.storeProductInGroup/support_function
    platform: android
    flow:
      # Get the name of the current group being processed...
      - storeIn:
          key: groupName
          value: ${cartFulfillmentGrouping.currentGroup}

      # Check if product was processed already...
      - executeNode:
          file: wcp/test/helpers/arrayContains.js
          args:
            - value: ${cartFulfillmentGrouping.processedProducts} # (array)
            - value: ${productName}                               # (searchValue)
          getResponse:
            storeIn: productNameAlreadyProcessed

      # If product was not processed already...
      - if:
          condition: '!${productNameAlreadyProcessed}'
          then:

            # Push it to processed products...
            - executeNode:
                file: wcp/test/helpers/arrayPush.js
                args:
                  - value: ${cartFulfillmentGrouping.processedProducts} # (array)
                  - value: ${productName}                               # (value)
                getResponse:
                  storeIn: cartFulfillmentGrouping.processedProducts

            # Push it into the groups json in the corresponding group...
            - executeNode:
                file: wcp/test/helpers/CartPage/fulfillmentGroupingJsonTools-addProduct.js
                args:
                  - value: ${cartFulfillmentGrouping.groupsJson} # (groupsJson)
                  - value: ${groupName}                          # (groupName)
                  - value: ${productName}                        # (productName)
                  - value: ${productPrice}                       # (productPrice)
                getResponse:
                  storeIn: cartFulfillmentGrouping.groupsJson

            # Log push confirmation...
            - log:
                message: "Product Stored in groupsJson: '${productName}'"
                color: CYAN

      - log:
          message: "End function: utils.json.CartFulfillmentGroupingBuilder.storeProductInGroup/support_function"
          color: BLUE

#----------------------------------------------------------------------------------------------------------------------

  # DESCRIPTION: [Support Function] [Supports: functions.utils.json.CartFulfillmentGroupingBuilder.buildGroupsJson]
  #
  #              Parses the Fulfillment Group Name based on the text of the element that identifies the group.
  #              This function already prepared to integrate logic for US and CA markets once required.
  #
  # PARAMS:   ${groupName}   [Mandatory]  As a param, it provides the original text that was obtained from the element that
  #                                       was identified as a group.
  #
  # RETURNS:  ${groupName}  As returned value, it overwrites the group name 'SCHEDULED' or 'UNSCHEDULED' based ond the
  #                         value received as param depending on the market the function is being executed on.
  #
  - name: functions.utils.json.CartFulfillmentGroupingBuilder.parseGroupNamePerMarket/support_function
    platform: android
    flow:
      - storeIn:
          key: originalGroupName
          value: ${groupName}
      - if:
          condition: ${market} == 'MX'
          then:
            - if:
                condition: ${groupName} == 'Reservar un horario' || ${groupName} == 'Pickup o envío a domicilio'
                then:
                  - storeIn:
                      key: groupName
                      value: SCHEDULED
            - if:
                condition: ${groupName} == 'Ver opciones' || ${groupName} == 'Envío a domicilio'
                then:
                  - storeIn:
                      key: groupName
                      value: UNSCHEDULED
      - log:
          message: Group Name '${originalGroupName}' parsed into '${groupName}' for ${market} market.
          color: GREEN
      - log:
          message: "End function: utils.json.CartFulfillmentGroupingBuilder.parseGroupNamePerMarket/support_function"
          color: BLUE

#----------------------------------------------------------------------------------------------------------------------

  # DESCRIPTION: [Support Function] [Supports: functions.utils.json.CartFulfillmentGroupingBuilder.buildGroupsJson]
  #
  #              Gest the Groups Json that has been built so far. It also prints it in the log.
  #              The value is obtained from the control variable 'cartFulfillmentGrouping.groupsJson'.
  #
  # RETURNS:  ${groupsJson}  The Group Json built.
  #
  - name: functions.utils.json.CartFulfillmentGroupingBuilder.getGroupsJson/support_function
    platform: android
    flow:
      - storeIn:
          key: groupsJson
          value: ${cartFulfillmentGrouping.groupsJson}
      - log:
          message: "Groups Json built: '${groupsJson}'"
          color: CYAN
      - log:
          message: "End function: utils.json.CartFulfillmentGroupingBuilder.getGroupsJson/support_function"
          color: BLUE

#----------------------------------------------------------------------------------------------------------------------

  # DESCRIPTION: This Builder analyzes the Cart Page, scrolling from top to bottom, looking for elements that identify
  #              the SCHEDULED and UNSCHEDULED fulfillment groups and the products that are contained within those
  #              groups.
  #
  #              Since the Cart Page does not have a useful hierarchy design where there are elements that represent
  #              a group that are working as containers of the products inside of them, this builder uses an approach
  #              where it traverses through the page looking for groups and products based on the order of appearance,
  #              assuming that when a group is found, all products that are displaying next are inside of it until a
  #              new group displays or the page ends.
  #
  #              This way, the builder is capable of building a well structured Json where the hierarchy is well
  #              represented and that can be used later for assertions on whether the Cart was able to group the
  #              products in the correct group as per the app criteria.
  #
  #              Example of the built Groups Json:
  #                 {
  #                     groups: [
  #                         {
  #                             name: "SCHEDULED",
  #                             products: [
  #                                 {
  #                                     name: "FunkoPop Pokemon Charizard",
  #                                     price: "$30.95"
  #                                 },
  #                                 {
  #                                     name: "UBC-C to USB-C Charging Cable",
  #                                     price: "$1.47"
  #                                 }
  #                             ]
  #                         },
  #                         {
  #                             name: "UNSCHEDULED",
  #                             products: [
  #                                 {
  #                                     name: "Great Value Milk 1l",
  #                                     price: "$1.20"
  #                                 }
  #                             ]
  #                         }
  #                     ]
  #                 }
  #
  # RETURNS:  ${groupsJson}  A stringified Json with the grouping hierarchy as explained in the description.
  #
  - name: functions.utils.json.CartFulfillmentGroupingBuilder.buildGroupsJson
    platform: android
    flow:
      - log:
          message: "Cart's Fulfillment Grouping Builder process started..."
          color: CYAN

      - executeFunction:
          name: functions.utils.json.CartFulfillmentGroupingBuilder.initialize/support_function

      # TODO: [Tech Debt] Find a way to be able to process mappings in a conventional way (R2 Mappings File) and simplify the process for this function.

      # NOTE: Context: R2 Existing mappings structure does not allow to pull mappings and store them as variables in order to be able to concatenate
      #       them ans work in an easier way. The logic of this function, due to the complexity, requires to concatenate them in order to create mappings
      #       that depend on the relationship between other. As of now, all the mappings that this function require will be handled inside this function
      #       only, in order to keep the function the most readable and maintainable possible.

      # Resource IDs...

      - storeIn:
          key: resourceIDs.fulfillmentCTAButton
          value: ${appPackage}:id/fulfillment_cta_button
      - storeIn:
          key: resourceIDs.fulfillmentMethodLabel
          value: ${appPackage}:id/fulfillment_method
      - storeIn:
          key: resourceIDs.itemDetailsContainer
          value: ${appPackage}:id/item_details
      - storeIn:
          key: resourceIDs.elementAtEndOfPage
          value: ${appPackage}:id/cart_pos_grand_total

      # Elements...

      - storeIn:
          key: elements.parentContainer # elementsContainerMapping
          value: //*[@resource-id="${appPackage}:id/cart_fragment_constraint_layout"]/*[@resource-id="${appPackage}:id/recyclerView"]
      - storeIn:
          key: elements.anyGroup # groupsMapping
          value: //*[@resource-id="${appPackage}:id/section_header_card"]//*[@resource-id="${resourceIDs.fulfillmentCTAButton}" or @resource-id="${resourceIDs.fulfillmentMethodLabel}"]
      - storeIn:
          key: elements.anyProduct # productsMapping
          value: //*[@resource-id="${appPackage}:id/cart_item_line_item"]//*[@resource-id="${resourceIDs.itemDetailsContainer}"]
      - storeIn:
          key: elements.anyGroupOrProduct # groupOrItemDetailsElements
          value: ${elements.anyGroup} | ${elements.anyProduct}
      - storeIn:
          key: elements.productNameChild # productNameMapping
          value: /*[@resource-id="${appPackage}:id/product_name"]
      - storeIn:
          key: elements.productPriceChild # productPriceMapping
          value: /*[@resource-id="${appPackage}:id/line_price"]

      # Expand all groups and scroll back to top to be able to start building the groups json...

      - executeFunction:
          name: functions.cartPage.expandAllFulfillmentGroupsIfContracted
      - executeFunction:
          name: functions.cartPage.scrollToPageTitle

      # Create a LOOP that behaves like a WHILE...

      #    - Create a boolean var that acts like a stop condition.
      #    - Make loop from 1 to 2.
      #    - At the beginning of each iteration, check for the stop condition...
      #         - If stop condition is met, break the loop.
      #         - If stop condition is not met, overwrite the loop index to 0 in order to make the loop apparently infinite.
      #    - At the end of each iteration, check if the stop condition is met to set it as 'true' in order to break the loop at the beginning of the next iteration.
      #      (this way, the loop will never be infinite)

      # Vars used for stop condition...

      - storeIn:
          key: checkElementAtEndOfPage
          value: false
      - storeIn:
          key: positionBeforeScrolling
          value: ' '
      - storeIn:
          key: positionAfterScrolling
          value: ' '

      # Start of WHILE loop...

      - loop:
          begin: 1
          end: 2
          storeIndex: trickyIndex
          flow:

            # WHILE's Stop Condition: If element at end of page has same position before scrolling and after scrolling, then we reached end of page and we can stop the WHILE loop...

            - if:
                condition: ${checkElementAtEndOfPage} && (${positionBeforeScrolling} == ${positionAfterScrolling})
                then:
                  - break: true
                else:
                  - storeIn:
                      key: trickyIndex
                      value: 0

            # Get position of element at end of page before scrolling only if displayed (we don't ask to check the element if it hasn't displayed yet)...

            - if:
                identifier:
                  present:
                    - identifier: ${resourceIDs.elementAtEndOfPage}
                  timeout: 100
                then:
                  - getString:
                      identifier: ${resourceIDs.elementAtEndOfPage}
                      attribute: bounds
                      storeIn: positionBeforeScrolling
                  - storeIn:
                      key: checkElementAtEndOfPage
                      value: true

            # Count how many groups and products are currently displayed in the parent container...

            - numberOfChildElements:
                identifier: ${elements.parentContainer}
                filterBy: ${elements.anyGroupOrProduct}
                storeIn: displayedElementsCount

            # Check if at least 1 group and/or product was displayed...

            - if:
                condition: ${displayedElementsCount} == 0
                then:
                  - log:
                      message: '${displayedElementsCount} groups and/or products found. Looking for more downwards...'
                      color: CYAN

                else:
                  - log:
                      message: '${displayedElementsCount} groups and/or products found. Looping through them to be processed...'
                      color: CYAN

                  # Loop through the groups and/or products displayed...

                  - loop:
                      begin: 0
                      end: ${displayedElementsCount}
                      storeIndex: elementIndex
                      flow:
                        - log:
                            message: '(index: ${elementIndex})...'
                            color: CYAN

                        # Get the resource id of the element...

                        - getString:
                            identifier: ${elements.anyGroupOrProduct}
                            attribute: resource-id
                            index: ${elementIndex}
                            storeIn: elementID

                        # Check if the resource id corresponds to an element that identifies a group...

                        - if:
                            condition: ${elementID} == ${resourceIDs.fulfillmentCTAButton} || ${elementID} == ${resourceIDs.fulfillmentMethodLabel}
                            then:
                              - log:
                                  message: 'Element identified as GROUP'
                                  color: CYAN
                              # Get the element's text to be used as group name...
                              - getString:
                                  identifier: ${elements.anyGroupOrProduct}
                                  attribute: text
                                  index: ${elementIndex}
                                  storeIn: groupName
                              # Parse the group name to SCHEDULED OR UNSCHEDULED per market...
                              - executeFunction:
                                  name: functions.utils.json.CartFulfillmentGroupingBuilder.parseGroupNamePerMarket/support_function # <--- ${groupName}
                              # Store the group name in the final hierarchy being built...
                              - executeFunction:
                                  name: functions.utils.json.CartFulfillmentGroupingBuilder.storeGroup/support_function # <--- ${groupName}

                            else:

                              # Check if the resource id corresponds to an element that identifies a product...

                              - if:
                                  condition: ${elementID} == ${resourceIDs.itemDetailsContainer}
                                  then:
                                    - log:
                                        message: 'Element identified as PRODUCT'
                                        color: CYAN
                                    # Find the product's name within the element's children...
                                    - getString:
                                        identifier: ${elements.anyGroupOrProduct}${elements.productNameChild}
                                        attribute: text
                                        index: ${elementIndex}
                                        storeIn: productName
                                    # Find the product's price within the element's children...
                                    - getString:
                                        identifier: ${elements.anyGroupOrProduct}${elements.productPriceChild}
                                        attribute: text
                                        index: ${elementIndex}
                                        storeIn: productPrice
                                    # Store the product information in the final hierarchy being built...
                                    - executeFunction:
                                        name: functions.utils.json.CartFulfillmentGroupingBuilder.storeProductInGroup/support_function # <--- ${productName}, ${productPrice}

                                  else:

                                    # If the resource id does not correspond to an element that identifies a group or a product, show a message...

                                    - log:
                                        message: '[!] Element not able to be identified as a group nor product'
                                        color: CYAN

                        #⬆︎ End Loop of displayed groups/products.

            # Scroll down for next iteration to be able to identify more groups and/or products...

            # - scroll:
            #     direction: down
            #     scrollLimit: 1
            #     config:
            #       startRatio: 0.5
            #       endRatio: 0.2

            # Get position of element at end of page after scrolling only if displayed...

            - if:
                identifier:
                  present:
                    - identifier: ${resourceIDs.elementAtEndOfPage}
                  timeout: 100
                then:
                  - getString:
                      identifier: ${resourceIDs.elementAtEndOfPage}
                      attribute: bounds
                      storeIn: positionAfterScrolling

            #⬆︎ End Loop that is working as a while.

      # Get the build json in the 'groupsJson' var and print it in the log...

      - executeFunction:
          name: functions.utils.json.CartFulfillmentGroupingBuilder.getGroupsJson/support_function # RETURNS ---> ${groupsJson}

      - log:
          message: "End function: utils.json.CartFulfillmentGroupingBuilder.buildGroupsJson"
          color: BLUE

  #--------------------------------------------------------------------------------------------------------------------

  # Param:  ${appPackage}  [Mandatory]  Android App Package to terminate.
  - name: functions.utils.terminateApp
    platform: android
    flow:
      - executeAppiumScript:
          method: "mobile: terminateApp"
          params:
            - key: appId
              value: ${appPackage}
      - log:
          message: "End function: utils.terminateApp"
          color: BLUE

  #--------------------------------------------------------------------------------------------------------------------

  # Param:  ${appPackage}  [Mandatory]  Android App Package to activate.
  - name: functions.utils.activateApp
    platform: android
    flow:
      - activateApp:
          packageName: ${appPackage}
      - log:
          message: "End function: utils.activateApp"
          color: BLUE

  #--------------------------------------------------------------------------------------------------------------------
  # Description: This function makes the whole process of close and start app again.
  # Param: ${appPackage}  [Optional]  App Package to re-launch. Default value for variable $appPackage is set since is set market info
  - name: functions.utils.relaunchApp
    platform: android
    flow:
      - executeFunction:
          name: functions.utils.terminateApp
          params:
            - name: appPackage
              string: ${appPackage}
      - sleep:
          duration: 3000
      - executeFunction:
          name: functions.utils.activateApp
          params:
            - name: appPackage
              string: ${appPackage}
      - sleep:
          duration: 5000
      - log:
          message: "End function: utils.relaunchApp"
          color: BLUE
