functions:

  #--------------------------------------------------------------------------------------------------------------------

  # Description: This method set the platform before the start of the execution
  # Params       No params
  - name: functions.utils.hideKeyboard
    platform: ios
    flow:
      - click:
          identifier:  global.doneBtn
      - log:
          message: "End function: utils.hideKeyboard"
          color: BLUE

  #--------------------------------------------------------------------------------------------------------------------

  # Description: Taps Next button in the keyboard.
  # No Params
  - name: functions.utils.keyboard.tapNextBtn
    platform: ios
    flow:
      - click:
          identifier:  global.nextBtn
      - log:
          message: "End function: functions.utils.keyboard.tapNextBtn"
          color: BLUE

  #--------------------------------------------------------------------------------------------------------------------

  # Description: This method gets the item count in cart 
  # Params       No params
  - name: functions.utils.getCartQuantity
    platform: ios
    flow:
      - getString:
          identifier: global.cartSummary
          attribute: label
          storeIn: cartQuantity
      - log:
          message: Current cart quantity ${cartQuantity}...
          color: CYAN
      - log:
          message: "End function: utils.hideKeyboard"
          color: BLUE

  #-----------------------------------------------------------------------------------------------------------------

  # Description: This function selects the value from the picker wheel.
  # Params:      ${valueToSelect}  [Mandatory] Select the value from drop down.
  # Works for:   [ MX [✓]   MX-Bodega [✓]   US [__] ]
  - name: functions.utils.selectValueFromDropDown
    platform: ios
    flow:
      - log:
          message: Select value from drop down - ${valueToSelect}.
          color: CYAN
      - enterText:
          identifier: utils.pickerWheel
          string: ${valueToSelect}
      - click:
          identifier: global.doneBtn
      - log:
          message: "End function: utils.selectValueFromDropDown"
          color: BLUE

  #-----------------------------------------------------------------------------------------------------------------
  # Description: This function get the page title.
  # No Params
  # Works for:   [ MX [__]   MX-Bodega [__]   US [__]   CA [✓]]
  - name: functions.utils.getPageTitle
    platform: ios
    flow:
      - getString:
          identifier: utils.pageTitle
          attribute: name
          storeIn: pageTitle
      - log:
          message: "End function: utils.selectValueFromDropDown"
          color: BLUE
  
  #--------------------------------------------------------------------------------------------------------------------
  # Description: This functions terminate app
  # No Param
  - name: functions.utils.terminateApp
    platform: ios
    flow:
      - terminateApp: true
  

  #--------------------------------------------------------------------------------------------------------------------
  # Description: This functions restarts the iOS build for the required market
  # No Param
  - name: functions.utils.restartiOSBuild
    platform: ios
    flow:
      - executeAppiumScript:
          method: "mobile: activateApp"
          params:
            - key: bundleId
              value: ${bundleId}
      - log:
          message: "End function: utils.restartiOSBuild"
          color: BLUE
    
  #--------------------------------------------------------------------------------------------------------------------
  # Description: This function makes the whole process of close and start app again.
  # PARAMS: ${bundleId}  [Optional]  Bundle Identifier to re-launch. $bundleId variable is set whe market info is set.
  - name: functions.utils.relaunchApp
    platform: ios
    flow:
      - executeFunction:
          name: functions.utils.terminateApp
      - sleep:
          duration: 1500
      - executeFunction:
          name: functions.utils.restartiOSBuild
          params:
            - name: bundleId
              string: ${bundleId}
      - sleep:
          duration: 5000
      - log:
          message: "End function: utils.relaunchApp"
          color: BLUE
  
    #-----------------------------------------------------------------------------------------------------------------
  # TEMPORAL FUNCTION, PLEASE ERASE WHEN MH ISSUE HAS BEEN FIXED IN IOS
  # Description: This function restarts the iOS app until GIC appears.
  # Param: No params
  - name: functions.utils.relaunchUntilGICAppears
    platform: ios
    flow:
      - loop:
          begin: 0
          end: 5
          flow:
            - sleep:
                duration: 5000
            - if:
                identifier:
                  present: 
                    - identifier: homePage.gic.expandedIcon
                then:
                  - break: true
                else:
                  - executeFunction:
                      name: functions.utils.terminateApp
                  - executeFunction:
                      name: functions.utils.restartiOSBuild
      - log:
          message: "End function: utils.relaunchUntilGICAppears"
          color: GREEN_BOLD

#----------------------------------------------------------------------------------------------------------------------

  # DESCRIPTION: This Builder analyzes the Cart Page looking for elements that identify as Fulfillment Groups
  #     (Scheduled & Unscheduled), EDD Groups, Seller Groups & Products.
  #
  #     The builder comes form the necessity of having to parse the Cart Page information into a JSON structure where
  #     to check if the products were grouped correctly because the Cart Page element's hierarchy has not been very well
  #     designed and there are no container elements that represent those groups. Due to this,there's not an easy way to
  #     perform the grouping assertions.
  #
  #     The builder's approach is to look for all the elements mentioned above, based on the order of appearance, assuming
  #     that when a group is found (is displayed in the screen), all products displayed next belong to that group until
  #     another group is found, in which case, all the product found next belong to this new group, until there are no
  #     more elements found.
  #
  #     The hierarchy is constructed based on the following precedence...
  #
  #         - Fulfillment Groups are at highest level.
  #             - EDD Groups are in the next level inside Fulfillment Groups.
  #                 - Seller Groups are in the next level inside EDD Groups.
  #                      - Products are in the next level inside Seller Groups.
  #
  #         * Note: Each group has also it's own products array which will contain all of the products that are spread
  #                 around the sub-groups inside of it (i.e. a Fulfillment Group will contain an array of all of the
  #                 products that its internal EDD Groups have and an EDD Group will have similar array containing all
  #                 of the products its internal Seller Groups have).
  #
  #     Following this process, the builder is capable of building a well structured JSON with a well represented
  #     hierarchy where the grouping assertions can be performed.
  #
  #     JSON Schema that will be constructed:
  #
  #       {
  #         fulfillmentGroups       : [Array of Fulfillment_Group],
  #         currentFulfillmentGroup : String,                        // Control var.
  #         currentEDDGroup         : String,                        // Control var.
  #         currentSellerGroup      : String,                        // Control var.
  #       }
  #
  #     Sub-schemas:
  #
  #       Fulfillment_Group:
  #           {
  #             name      : String,
  #             products  : [Array of Strings],   // The actual name of the products.
  #             eddGroups : [Array of EDD_Group]
  #           }
  #
  #       EDD_Group:
  #           {
  #             name         : String,
  #             products     : [Array of Strings],      // The actual name of the products.
  #             sellerGroups : [Array of Seller_Group]
  #           }
  #
  #       Seller_Group:
  #           {
  #             name         : String,
  #             products     : [Array of Strings]  // The actual name of the products.
  #           }
  #
  # NO PARAMS
  # RETURNS:  ${CartGrouping.JSON}  A stringified Json with the grouping hierarchy as explained in the description.
  #
  - name: functions.utils.CartGroupingJSONBuilder.build
    platform: ios
    flow:
      - log:
          message: "Cart's Fulfillment Grouping Builder process started..."
          color: CYAN

      - executeFunction:
          name: functions.utils.CartGroupingJSONBuilder.initialize/support_function

      # Resource Names...
      # NOTE: use only values that are coming in the 'name' property...

      - storeIn:
          key: resourceNames.SCGroup            # Identifies a Fulfillment Group.
          value: SCGroup_fulfillmentPlaceLabel
      - storeIn:
          key: resourceNames.FCGroup            # Identifies a Fulfillment Group.
          value: FCGroup_fulfillmentPlaceLabel
      - storeIn:
          key: resourceNames.EDDElement         # Identifies an EDD Group.
          value: Llega
      - storeIn:
          key: resourceNames.productName        # Identifies a Product.
          value: CartItemTileView.nameLabel

      # Elements...
      # NOTE: construct only Xpath mappings/locators; the process will only work with Xpath locators.

      - storeIn:
          key: elements.parentContainer
          value: //*[@name="CartViewController.containerView"]
      - storeIn:
          key: elements.anyGroup
          value: self::*[@name="${resourceNames.SCGroup}"] or self::*[@name="${resourceNames.FCGroup}"]
      - storeIn:
          key: elements.anyEDD
          value: self::XCUIElementTypeOther[starts-with(@name,"${resourceNames.EDDElement}")]
      - storeIn:
          key: elements.anyProduct
          value: self::*[@name="${resourceNames.productName}"]
      - storeIn:
          key: elements.anyParsableElement
          value: //*[${elements.anyGroup} or ${elements.anyEDD} or ${elements.anyProduct}]

                # NOTE: the above mapping is the final xpath to be used to identify any possible Fulfillment Group, EDD Group or Product.
                #       Please note that it must be just a single xpath and not a concatenation of multiple xpath through "|".
                #       This is because this way Appium will resolve xpath matches in order of appearance, because when an xpath construction
                #       like "xpath1 | xpath2 | xpath3 | etc..." is used, Appium resolves each xpath individually and then merges the
                #       resulting arrays in a single array, resulting in the matches not being listed in order of appearance.

      # Expand all groups and scroll back to top to be able to start building the groups json...
      - executeFunction:
          name: functions.cartPage.expandAllFulfillmentGroupsIfContracted
      - executeFunction:
          name: functions.cartPage.scrollToPageTitle

      # Count how many parsable elements are currently displayed in the parent container...
      - numberOfChildElements:
          identifier: ${elements.parentContainer}
          filterBy: ${elements.anyParsableElement}
          storeIn: displayedElementsCount

      # Stop fetching page source because page will not be refreshed now as it is not required (this will speed up the execution)...
      - fetchPageSource: false

      # Check if there were elements displayed...
      - if:
          condition: ${displayedElementsCount} == 0
          then:
            - log:
                message: '0 Fulfillment Groups/EDD Groups/Products found.'
                color: CYAN
          else:

            # If elements displayed, process them...
            - log:
                message: '${displayedElementsCount} Fulfillment Groups/EDD Groups/Products found.'
                color: CYAN
            - log:
                message: "Searched locator: ${elements.anyParsableElement}"
                color: GREEN

            # Loop through the count of elements displayed to process each single element...
            - loop:
                begin: 0
                end: ${displayedElementsCount}
                storeIndex: loopIndex
                flow:
                  - log:
                      message: 'Processing element (index: ${loopIndex})...'
                      color: CYAN

                  # Transform xpath to be used to an xpath based on index position...
                  - executeNode:
                      file: wcp/test/helpers/CartPage/GroupingJsonTools-xpathPositionalTransformer.js
                      args:
                        - value: ${elements.anyParsableElement} # xpath to transform
                        - value: ${loopIndex}                   # index from the R2 loop (0-index base)
                      getResponse:
                        storeIn: xpathString

                  # Get the name property of the resulting positional xpath...
                  - getString:
                      identifier: ${xpathString}
                      attribute: name
                      storeIn: elementName
                  - log:
                      message: 'Element Name found: ${elementName}'
                      color: GREEN

                  # Create a var to identify whether the element was able to be identified...
                  - storeIn:
                      key: elementAbleToBeIdentified
                      value: false

                  # Check if the element name corresponds to one that identifies as a FULFILLMENT GROUP...
                  - if:
                      condition: ${elementName} == ${resourceNames.SCGroup} || ${elementName} == ${resourceNames.FCGroup}
                      then:
                        - log:
                            message: 'Element identified as [ Fulfillment Group ]'
                            color: GREEN

                        # Get the element's text to be used as group name...
                        - if:
                            condition: ${elementName} == ${resourceNames.SCGroup}
                            then:
                              - storeIn:
                                  key: groupName
                                  value: SCHEDULED
                        - if:
                            condition: ${elementName} == ${resourceNames.FCGroup}
                            then:
                              - storeIn:
                                  key: groupName
                                  value: UNSCHEDULED

                        # Store the element in the final hierarchy being built...
                        - executeFunction:
                            name: functions.utils.CartGroupingJSONBuilder.saveFulfillmentGroup/support_function # <--- ${groupName}

                        # Set element as identified...
                        - storeIn:
                            key: elementAbleToBeIdentified
                            value: true

                        # Notify how the element was identified...
                        - log:
                            message: ( Index ${loopIndex} ) FULFILLMENT GROUP | ${elementName}
                            color: CYAN
                      
                      else:

                        # Else: check if the element name corresponds to one that identifies as an EDD GROUP...
                        - executeNode:
                            file: wcp/test/helpers/stringStartsWith.js
                            args:
                              - value: ${elementName}
                              - value: ${resourceNames.EDDElement}
                            getResponse:
                              storeIn: elementIsIdentifiedAsEDD
                        - if:
                            condition: ${elementIsIdentifiedAsEDD}
                            then:
                              - log:
                                  message: 'Element identified as [ EDD Group ]'
                                  color: GREEN

                              # Store the element in the final hierarchy being built...
                              - executeFunction:
                                  name: functions.utils.CartGroupingJSONBuilder.saveEDDGroup/support_function
                                  params:
                                    - name: groupName
                                      string: ${elementName}

                              # Set element as identified...
                              - storeIn:
                                  key: elementAbleToBeIdentified
                                  value: true

                              # Notify how the element was identified...
                              - log:
                                  message: Index ${loopIndex} >>> EDD Group >>> ${elementName}
                                  color: CYAN

                            else:

                              # Else: check if the resource id corresponds to an element that identifies a PRODUCT...
                              - if:
                                  condition: ${elementName} == ${resourceNames.productName}
                                  then:
                                    - log:
                                        message: 'Element identified as [ Product ]'
                                        color: GREEN

                                    # Get the element's label to be used as Product Name...
                                    - getString:
                                        identifier: ${xpathString}
                                        attribute: label
                                        storeIn: productName

                                    # Store the product name in the final hierarchy being built...
                                    - executeFunction:
                                        name: functions.utils.CartGroupingJSONBuilder.saveProduct/support_function # <--- ${productName}

                                    # Set element as identified...
                                    - storeIn:
                                        key: elementAbleToBeIdentified
                                        value: true

                                    # Notify how the element was identified...
                                    - log:
                                        message: Index ${loopIndex} >>> Product >>> ${productName}
                                        color: CYAN

                  #⬆︎ End If (logic to identify type of element)

                  # Send warning message if element was not able to be identified and not processed...
                  - if:
                      condition: '!${elementAbleToBeIdentified}'
                      then:
                        - log:
                            message: "[!] Index ${loopIndex} >>> Element not able to be identified (Fulfillment Group, EDD Group, Seller Group nor Product)."
                            color: CYAN

            #⬆︎ End Loop (logic to iterate through displayed elements).

      #⬆︎ End If (logic to check if there were displayed elements).

      # Start fetching page again as we already finished the process that do not required page fetching...
      - fetchPageSource: true

      # Get the built json in the 'groupsJson' var and print it in the log...
      - executeFunction:
          name: functions.utils.CartGroupingJSONBuilder.getGroupsJson # RETURNS ---> ${CartGrouping.JSON}

      - log:
          message: "End function: utils.CartGroupingJSONBuilder.build"
          color: BLUE
    