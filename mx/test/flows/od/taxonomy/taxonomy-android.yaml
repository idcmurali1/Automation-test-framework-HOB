#======================================================================================================================
#
#    AUTHOR: Sergio Fernandez (vn0t1qt)
#   CREATED: Jun/14/2023
#  REVISION: ---
#
#  Copyright © 2023 Walmart. All rights reserved.
#======================================================================================================================

functions:

#----------------------------------------------------------------------------------------------------------------------

  # DESCRIPTION: This flow is used to increase a Product's Quantity to its Max Quantity Limit based on its type. It 
  #     returns the Final Max Quantity.
  #
  #     For Pieces Products > Max Quantity Limit is 99 pieces.
  #     For Weight Products > Max Quantity Limit is 20 kg (20,000 grams).
  #     For Dual Products   > Max Quantity Limit is 20 kg (20,000 grams).
  #
  #     *   Consider that the supplier store may not have enough stock of the desired product to provide up to 99
  #         pieces or 20 kg. So, the Max Quantity Limit may be capped based on the Product's Available Stock.
  #
  #         i.e. If the supplier store has only 15 pieces of the given product, the flow will not be able to increase
  #              its quantity up to 99 pieces. Instead, it will identify the Max Available Stock was reached and will
  #              return 15 as the Final Max Quantity, for the developer to use this value, instead of the original
  #              99 pieces limit, for future assertions or calculations.
  #
  #     *   This flow is a wrapper function. Which calls any of the 2 following sub-flows depending on the Product's
  #         Type:
  #             - mx.flows.od.taxonomy.increasePiecesProductToMaxQuantity
  #             - mx.flows.od.taxonomy.increaseDualOrWeighableProductToMaxQuantity
  #
  # PARAMS:
  #     ${productName}  [Mandatory]
  #         Name of the Product which quantity is going to be increased.
  #
  #     ${productType}  [Mandatory]
  #         Type of the Product. Used to determine the sub-flow that is going to be executed to perform que quantity increase.
  #         Options: [ Pieces | Dual | Weight | Weighable ]
  #
  #     ${productWeightConversionRate} [Conditional]
  #         Used only for Dual and Weighable Products. Represents the weight of 1 piece of the product.
  #         i.e. For a Dual Product like an Apple: 1 apple weights 90 grams.
  #              For a Weighable Product like Turkey Jam: 1 slice weights 30 grams.
  #              (These values can be obtained from the app)
  #
  # RETURNS:
  #
  #     ${returnedMaxQuantity}
  #
  #         The Final Max Quantity that the product was able to be increased to. This value is returned to enable the
  #         developer to identify what was the Max Quantity the Product was able to be increased to, and it can hold
  #         one of the following possible values...
  #
  #         - 99
  #
  #             For Pieces products, when the Supplier Store has enough stock to supply up to the Max Quantity Limit.
  #
  #         - The resulting number of grams <= 20000 based on the following formula:
  #           Integer(20000 / ${productWeightConversionRate}) * ${productWeightConversionRate}
  #
  #             For Dual and Weighable Products, when the Supplier Store has enough stock to supply up to the Max
  #             Quantity Limit. The formula is needed because there are products which it's weight is not an exact
  #             divisor of 20000 grams, so the app caps the Max Quantity Limit to the max number of grams not greater
  #             than 20000 based on the product's weight.
  #
  #             i.e. a product that weights 79 grams (let's say a slice of Turkey Jam), would return 19987 grams (the
  #                  equivalent of 253 slices), because if we'd try to increase the quantity 1 more time (254 slices),
  #                  it would increase to 20066 grams and this number is grater than the Max Quantity Limit of 20 kg.
  #
  #         - The Max Available Stock
  #             For Pieces, Dual or Weighable Products, when the supplier stock does not have enough stock to supply up
  #             to the Max Quantity Limit.
  #
  #     ${returnedMaxPiecesConversion}
  #
  #         The Final Max Quantity that the product was increased to, converted to Pieces. This value makes sense only
  #         for Weighable and Dual Products.
  #
  #         For Pieces Products, it returns the same value as returned in 'returnedMaxQuantity'.
  #         For Weighable Products, it returns '1' (because Weighable products are counted as 1 piece).
  #         For Dual Products, it returns the total weight added converted to Pieces.
  #
  # AUTHOR: Sergio Fernandez (vn0t1qt)
  - name: mx.flows.od.taxonomy.increaseProductToMaxQuantity
    platform: android
    flow:
      - log:
          message: "Product Name: '${productName}'"
          color: CYAN
      - log:
          message: "Product Type: '${productType}'"
          color: CYAN
      - log:
          message: "Product Weight Conversion Rate: '${productWeightConversionRate}' (grams)"
          color: CYAN
      # Check correct ${productType} value...
      - if:
          condition: ${productType} != 'Pieces' && ${productType} != 'Dual' && ${productType} != 'Weight' && ${productType} != 'Weighable'
          then:
            - failTest:
                message: "Flow Failure: Invalid Product Type provided: '${productType}'"
      - log:
          message: "Executing corresponding increase quantity flow based on the product's type..."
          color: GREEN
      # Verify which flow will be triggered based on the product's type...
      - if:
          condition: ${productType} == 'Pieces'
          then:
            # Pieces Product increase quantity trigger...
            - executeFunction:
                name: mx.flows.od.taxonomy.increasePiecesProductToMaxQuantity # <--PARAM--${productName}
                # --RETURNS--${returnedMaxQuantity}-->
            - storeIn:
                key: returnedMaxPiecesConversion
                value: ${returnedMaxQuantity}
                # --RETURNS--${returnedMaxPiecesConversion}-->
      - if:
          condition: ${productType} == 'Dual' || ${productType} == 'Weight' || ${productType} == 'Weighable'
          then:
            # Dual and Weight Product increase quantity trigger...
            - executeFunction:
                name: mx.flows.od.taxonomy.increaseDualOrWeighableProductToMaxQuantity # <--PARAM--${productName}--${productType}--${productWeightConversionRate}
                # --RETURNS--${returnedMaxQuantity}-->
                # --RETURNS--${returnedMaxPiecesConversion}-->
      - log:
          message: "End function: flows.od.taxonomy.increaseProductToMaxQuantity"
          color: BLUE

#----------------------------------------------------------------------------------------------------------------------

  # DESCRIPTION: Support sub-flow for 'mx.flows.od.taxonomy.increaseProductToMaxQuantity'. Increases the given Pieces
  #     Product to its Max Quantity Limit, and returns the Final Max Quantity.
  #
  #     *   See documentation of 'mx.flows.od.taxonomy.increaseProductToMaxQuantity' for additional details.
  #
  # PARAMS:  ${productName}  [Mandatory]  Name of the Product to increase its quantity.
  #
  # RETURNS:  ${returnedMaxQuantity}  The Final Max Quantity that the product was increased to.
  #
  # AUTHOR: Sergio Fernandez (vn0t1qt)
  - name: mx.flows.od.taxonomy.increasePiecesProductToMaxQuantity
    platform: android
    flow:
      - log:
          message: "Product Name: '${productName}'"
          color: CYAN
      - log:
          message: "Max Purchase Limit: '99 pieces' (if enough stock available)"
          color: CYAN

      # Initial value for max quantity reached flag...
      - storeIn:
          key: productReachedMaxQuantity
          value: false

      # Start a loop of 5 cycles where the quantity of the product is increased by 20 pieces...
      # (5 cycles of 20 increments = 99+ pieces incremented)
      - loop:
          begin: 0
          end: 5
          storeIndex: cycleIndex
          flow:
            # Expand quantity button...
            - click:
                identifier: mx.mappings.department-l3.collapsedQuantityOrAddToCartButtonByProductName # <--PARAM--${productName}

            # Increment the quantity 20 times...
            - try:
                flow:
                  # If the Max Available Stock is reached, a pop-up is shown and the increase button becomes not clickable,
                  # so an exception is thrown when trying to click the button...
                  - click:
                      identifier: mx.mappings.department-l3.increaseButtonForProduct # <--PARAM--${productName}
                      numberOfClicks: 20
                      waitBetweenClicks: 1
                catch:
                  flow:
                    # If the exception happened, just log a message, the TC should't fail...
                    - log:
                        message: "Increase button not clickable anymore, process will continue."
                        color: CYAN

            - sleep:
                duration: 5000

            # At this moment there should be 2 cases that might happened...
            # 1) The Max Available Stock might have been reached (because the supplier store does not have enough stock to supply the Max Quantity Limit), or...
            # 2) The 20 increments were done successfully (in which case we still don't know if the Max Quantity Limit was reached or not)

            # Check if the Max Available Stock notification popup is shown...
            - if:
                identifier:
                  present:
                    - identifier: mx.mappings.department-l3.max-stock-reached-popup.title
                then:
                  # If so, close the popup, set the ${productReachedMaxQuantity} flag to true, and break the loop...
                  # (because it means the product reached the Max Available Stock in the supplier store)
                  - log:
                      message: "Product's Max Available Stock reached!!!"
                      color: CYAN
                  - click:
                      identifier: mx.mappings.department-l3.max-stock-reached-popup.understoodButton
                  - if:
                      identifier:
                        present:
                          - identifier: mx.mappings.department-l3.max-stock-reached-popup.understoodButton
                        timeout: 3000
                      then:
                        - click:
                            identifier: mx.mappings.department-l3.max-stock-reached-popup.understoodButton
                  - storeIn:
                      key: productReachedMaxQuantity
                      value: true
                  - break: true
                else:
                  # If not, get the current displayed quantity and use it to assert whether we reached the Max Quantity Limit or not yet...
                  - getString:
                      identifier: mx.mappings.department-l3.collapsedQuantityLabelByProductName # <--PARAM--${productName}
                      storeIn: currentQuantity
                  - log:
                      message: "Current Quantity: '${currentQuantity}' (pieces)"
                      color: GREEN
                  # Check if the product reached the Max Quantity Limit...
                  - executeNode:
                      file: mx/test/helpers/utils/stringContainsAny.js
                      args:
                        - value: ${currentQuantity}
                        - value: "Máx. 99 | Max. 99 | Max.99 | Máx.99 | 99"
                      getResponse:
                        storeIn: productReachedMaxQuantity
                  - if:
                      condition: ${productReachedMaxQuantity} == true
                      then:
                        # If so, break the loop...
                        - log:
                            message: "Max Quantity Limit reached!!!"
                            color: CYAN
                        - break: true
                      else:
                        # If not, the loop should continue, we just log a message to notify the user the max limit has not been reached yet...
                        - arithmetic:
                            expression: ${cycleIndex} + 1
                            storeIn: tryNumber
                        - log:
                            message: "Max Quantity has not been reached yet (try ${tryNumber}/5)"
                            color: CYAN

      # Once the loop finished, either because of a break or all the cycles were executed...
      # Check whether the ${productReachedMaxQuantity} flag was set to 'true' or 'false'...
      - if:
          condition: ${productReachedMaxQuantity} == true
          then:
            # If equals to true, collect the current displayed quantity, clean it up and return it...
            - getString:
                identifier: mx.mappings.department-l3.collapsedQuantityLabelByProductName # <--PARAM--${productName}
                storeIn: returnedMaxQuantity
            - executeNode:
                file: mx/test/helpers/utils/sanitizeQuantity.js
                args:
                  - value: ${returnedMaxQuantity}
                getResponse:
                  storeIn: returnedMaxQuantity
            - log:
                message: "Max Quantity Got: '${returnedMaxQuantity}' (pieces)"
                color: CYAN
          else:
            # If equals to false, fail the test case...
            - failTest:
                message: "Products Max Quantity was never reached in 5 cycles of 20 increments"

      - log:
          message: "End function: flows.od.taxonomy.increasePiecesProductToMaxQuantity"
          color: BLUE

#----------------------------------------------------------------------------------------------------------------------

  # DESCRIPTION: Support sub-flow for 'mx.flows.od.taxonomy.increaseProductToMaxQuantity'. Increases the given Dual or
  #     Weighable Product to its Max Quantity Limit, and returns the Final Max Quantity.
  #
  #     *   See documentation of 'mx.flows.od.taxonomy.increaseProductToMaxQuantity' for additional details.
  #
  # PARAMS:  ${productName}                  [Mandatory]  Name of the Product to increase its quantity.
  #          ${productType}                  [Mandatory]  Type of the Product. Options: [ Dual | Weight | Weighable ]
  #          ${productWeightConversionRate}  [Mandatory]  How much grams are equal to 1 piece of the product.
  #
  # RETURNS:
  #     ${returnedMaxQuantity}          The Final Max Quantity that the product was increased to (as Weight).
  #     ${returnedMaxPiecesConversion}  The Final Max Quantity that the product was increased to (as Pieces).
  #
  # AUTHOR: Sergio Fernandez (vn0t1qt)
  - name: mx.flows.od.taxonomy.increaseDualOrWeighableProductToMaxQuantity
    platform: android
    flow:
      # Calculate the max purchase limit based on product's weight conversion rate...
      - arithmetic:
          expression: 20000 / ${productWeightConversionRate}
          asInt: true
          storeIn: maxPurchaseLimitBasedOnWeightConversionRate # Gets only the integer part of the division.
      - arithmetic:
          expression: ${maxPurchaseLimitBasedOnWeightConversionRate} * ${productWeightConversionRate}
          asInt: true
          storeIn: maxPurchaseLimitBasedOnWeightConversionRate

      - log:
          message: "Product Name: '${productName}'"
          color: CYAN
      - log:
          message: "Product Type: '${productType}'"
          color: CYAN
      - log:
          message: "Product Weight Conversion Rate: '${productWeightConversionRate}' (grams)"
          color: CYAN
      - log:
          message: "Max Purchase Limit: '20000' (grams) (if enough stock available)"
          color: CYAN
      - log:
          message: "Max Purchase Limit (based on Weight Conversion Rate): '${maxPurchaseLimitBasedOnWeightConversionRate}' (grams) (if enough stock available)"
          color: CYAN

      # Validation of the correct product type...
      - if:
          condition: ${productType} == 'Pieces'
          then:
            - failTest:
                message: "Invalid Product Type: '${productType}' not accepted for this function."

      # Calculate the number of increments that is going to be used in the loop based on the productWeightConversionRate...
      - arithmetic:
          expression: 4000 / ${productWeightConversionRate}
          asInt: true
          storeIn: numberOfIncrements # Gets only the integer part of the division.

      # Increment numberOfIncrements by 1 (to always compensate de decimals in case of the calculation had decimals originally)...
      - arithmetic:
          expression: ${numberOfIncrements} + 1
          asInt: true
          storeIn: numberOfIncrements

      # Initial value for productReachedMaxQuantity flag to determine whether the max quantity was reached...
      - storeIn:
          key: productReachedMaxQuantity
          value: false

      # Start a loop of 5 cycles where the quantity of the product is increased by a calculated number of increments...
      # (i.e. 5 cycles of 80 increments (for a product which weight is 50 g) = 20,000+ grams incremented)
      - loop:
          begin: 0
          end: 5
          storeIndex: cycleIndex
          flow:
            # Expand quantity button...
            - click:
                identifier: mx.mappings.department-l3.collapsedQuantityOrAddToCartButtonByProductName # <--PARAM--${productName}

            # Switch to grams in case the product is a Dual product...
            - if:
                condition: ${cycleIndex} == 0 && ${productType} == 'Dual'
                then:
                  - click:
                      identifier: mx.mappings.department-l3.weightOption # <--PARAM--${productName}

            # Increment the quantity as many times as 'numberOfIncrements'...
            - try:
                flow:
                  # If the Max Available Stock is reached, a pop-up is shown and the increase button becomes not clickable,
                  # so an exception is thrown when trying to click the button.
                  - click:
                      identifier: mx.mappings.department-l3.increaseButtonForProduct # <--PARAM--${productName}
                      numberOfClicks: ${numberOfIncrements}
                      waitBetweenClicks: 1
                catch:
                  flow:
                    # If the exception happened, just log a message, the TC should't fail...
                    - log:
                        message: "Increase button not clickable anymore, process will continue."
                        color: CYAN

            - sleep:
                duration: 5000

            # At this moment there should be 2 cases that might happened...
            # 1) The Max Available Stock might have been reached (because the supplier store does not have enough stock to supply the Max Quantity Limit), or...
            # 2) All the increments were done successfully (in which case we still don't know if the Max Quantity Limit was reached or not)

            # Check if the Max Available Stock notification popup is shown...
            - if:
                identifier:
                  present:
                    - identifier: mx.mappings.department-l3.max-stock-reached-popup.title
                then:
                  # If so, close the popup, set the ${productReachedMaxQuantity} flag to true, and break the loop...
                  # (because it means the product reached the Max Available Stock in the supplier store)
                  - log:
                      message: "Product's Max Available Stock reached!!!"
                      color: CYAN
                  - click:
                      identifier: mx.mappings.department-l3.max-stock-reached-popup.understoodButton
                  - if:
                      identifier:
                        present:
                          - identifier: mx.mappings.department-l3.max-stock-reached-popup.understoodButton
                        timeout: 3000
                      then:
                        - click:
                            identifier: mx.mappings.department-l3.max-stock-reached-popup.understoodButton
                  - storeIn:
                      key: productReachedMaxQuantity
                      value: true
                  - break: true
                else:
                  # If not, get the current displayed quantity and use it to assert whether we reached the Max Quantity Limit or not yet...
                  - getString:
                      identifier: mx.mappings.department-l3.collapsedQuantityLabelByProductName # <--PARAM--${productName}
                      storeIn: currentQuantity
                  - log:
                      message: "Current Quantity: '${currentQuantity}' (grams)"
                      color: GREEN
                  # Check if the product reached the Max Quantity Limit...
                  - storeIn:
                      key: limit
                      value: ${maxPurchaseLimitBasedOnWeightConversionRate}
                  - executeNode:
                      file: mx/test/helpers/utils/stringContainsAny.js
                      args:
                        - value: ${currentQuantity}
                        - value: "Máx. ${limit} g | Max. ${limit} g | Máx.${limit} g | Max.${limit} g | ${limit} g"
                      getResponse:
                        storeIn: productReachedMaxQuantity
                  - if:
                      condition: ${productReachedMaxQuantity} == true
                      then:
                        # If so, break the loop...
                        - break: true
                      else:
                        # If not, the loop should continue, we just log a message to notify the user the max limit has not been reached yet...
                        - arithmetic:
                            expression: ${cycleIndex} + 1
                            storeIn: tryNumber
                        - log:
                            message: "Max Quantity has not been reached yet (try ${tryNumber}/5)."
                            color: CYAN

      # Once the loop finished, either because of a break or all the cycles were executed...
      # Check whether the ${productReachedMaxQuantity} flag was set to 'true' or 'false'...
      - if:
          condition: ${productReachedMaxQuantity} == true
          then:
            # If equals to true, collect the current displayed quantity, clean it up and return it...
            - getString:
                identifier: mx.mappings.department-l3.collapsedQuantityLabelByProductName # <--PARAM--${productName}
                storeIn: returnedMaxQuantity
            - executeNode:
                file: mx/test/helpers/utils/sanitizeQuantity.js
                args:
                  - value: ${returnedMaxQuantity}
                getResponse:
                  storeIn: returnedMaxQuantity
                  # --RETURNS--${returnedMaxQuantity}-->
            - if:
                condition: ${productType} == 'Weighable' || ${productType} == 'Weight'
                then:
                  - storeIn:
                      key: returnedMaxPiecesConversion
                      value: 1
                      # --RETURNS--${returnedMaxPiecesConversion}-->
                else:
                  - arithmetic:
                      expression: ${returnedMaxQuantity} / ${productWeightConversionRate}
                      asInt: true
                      storeIn: returnedMaxPiecesConversion # Gets only the integer part of the division.
                      # --RETURNS--${returnedMaxPiecesConversion}-->
            - log:
                message: "Max Quantity Got: '${returnedMaxQuantity}' (grams)"
                color: CYAN
            - log:
                message: "Max Quantity Got: '${returnedMaxPiecesConversion}' (pieces)"
                color: CYAN
          else:
            # If equals to false, fail the test case...
            - failTest:
                message: "Products Max Quantity was never reached in 5 cycles of ${numberOfIncrements} increments"

      - log:
          message: "End function: mx.flows.od.taxonomy.increaseDualOrWeighableProductToMaxQuantity"
          color: BLUE