#======================================================================================================================
#    AUTHOR: Sergio Fernandez Aldana (vn0t1qt))
#   CREATED: Feb/17/2023
#  REVISION: ---
#
#  Copyright © 2023 Walmart. All rights reserved.
#======================================================================================================================

functions:

  # DESCRIPTION: Performs all the following assertions for the given product name.
  #   - Listed/NotListed: Whether the product is listed or not listed in the Cart.
  #   - Availability: Whether the product is listed in the Available Products List or the OOS Products list.
  #   - Expected Quantity: Whether the displayed expected quantity is correct. This assertion is performed based in the Product Type which is calculated by the function.
  #   - Expected Price: Whether the displayed price (unit price) is correct.
  #   - Expected Subtotal: Whether the displayed subtotal is correct.
  # PARAMS:  ${productName}             [Mandatory]  Name of the product to perform assertions for.
  #          ${productListed}           [Mandatory]  Option to check whether the product is listed or not listed in the Cart. Options: [ listed | notListed ]
  #                                                    If option is 'notListed', this method will perform only this assertion will omit all the other assertions.
  #          ${availability}            [Mandatory]  Option to check whether the product should be listed in the Available or the OOS Products List. Options: [ available | notAvailable | null ]
  #                                                    If option is 'notAvailable', this method will perform this assertion but will not perform Expected Quantity, Expected Price and Expected Subtotal assertions.
  #                                                    If option is 'null', this assertion will be skipped (also the Expected Quantity, Expected Price and Expected Subtotal assertions will be skipped).
  #          ${expectedQuantity}        [Mandatory]  Expected quantity the product should show. Options: [ <numeric value> | null ]
  #                                                    If option is a numeric value, the method will assert that as the expected quantity the product should display.
  #                                                    If option is 'null', this assertion will be skipped.
  #          ${expectedWeightQuantity}  [Mandatory]  Expected weight quantity the product should should. Options: [ <numeric value> ]
  #                                                    It is needed only when the product is 'Weight' or 'Dual'. For 'Pieces' products it is not; it can be empty value or 'null'.
  #          ${expectedUnitPrice}       [Mandatory]  Expected price the product should show. Options: [ <numeric value> | null ]
  #                                                    If option is a numeric value, the method will assert that as the expected price the product should display.
  #                                                    If option is 'null', this assertion will be skipped.
  #          ${expectedSubtotal}        [Mandatory]  Expected sub-total the product should show. Options: [ <numeric value> | null ]
  #                                                    If option is a numeric value, the method will assert that as the expected subtotal the product should display.
  #                                                    If option is 'null', this assertion will be skipped.
  # RETURNS: ${returnedFinalSubtotal}   This is the updated product subtotal that will be calculated in case a product with Multi-Savings promotion was found in cart.
  - name: mx.flows.od.cart.performProductAssertions
    platform: android
    flow:
      - log:
          message: "Product Name: ${productName}"
          color: CYAN
      - log:
          message: "Product Listed/NotListed Assertion (${productListed})..."
          color: CYAN
      - if:
          condition: ${productListed} == 'notListed' # for not listed products...
          then:
            - executeFunction:
                name: mx.functions.cart.assertProductNotListed
          else: 
            - if:
                condition: ${productListed} == 'listed'  # for listed products...
                then:
                  - executeFunction:
                      name: mx.functions.cart.assertProductListed
                  # Availability Assertion...
                  - log:
                      message: "Availability Assertion (${availability})..."
                      color: CYAN
                  - if:
                      condition: ${availability} == null
                      then:
                        - log:
                            message: "Availability Assertion Skipped (availability = null)"
                            color: CYAN
                      else:
                        - if:
                            condition: ${availability} == 'available' # for available products...
                            then:
                              - executeFunction:
                                  name: mx.functions.cart.assertProductListedAsAvailable
                                  params:
                                    - name: direction
                                      string: up
                              - executeFunction:
                                  name: mx.functions.cart.assertProductNotListedAsOOS
                                  params:
                                    - name: direction
                                      string: down
                              # Expected Quantity Assertion...
                              - log:
                                  message: "Expected Quantity Assertion (Pieces: ${expectedQuantity} | Weight: ${expectedWeightQuantity})..."
                                  color: CYAN
                              - executeFunction:
                                  name: mx.functions.cart.getProductType
                              - if:
                                  condition: ${expectedQuantity} == null
                                  then:
                                    - log:
                                        message: "Quantity Assertion Skipped (expectedQuantity = null)"
                                        color: CYAN
                                  else:
                                    - if:
                                        condition: ${returnedProductType} == 'Pieces' # for 'Pieces' products...
                                        then:
                                          - executeFunction:
                                              name: mx.functions.cart.assertProductQuantityAsPieces
                                              params:
                                                - name: quantity
                                                  string: ${expectedQuantity}
                                        else:
                                          - if:
                                              condition: ${returnedProductType} == 'Weighable' || ${returnedProductType} == 'Weight' # for 'Weight' products...
                                              then:
                                                - executeFunction:
                                                    name: mx.functions.cart.assertProductQuantityAsWeight
                                                    params:
                                                      - name: expectedQuantity
                                                        string: ${expectedWeightQuantity}
                                              else: # for 'Dual' products...
                                                - executeFunction:
                                                    name: mx.functions.cart.switchProductToPieces
                                                    params:
                                                      - name: direction
                                                        string: down
                                                - sleep:
                                                    duration: 3000
                                                - executeFunction:
                                                    name: mx.functions.cart.assertProductQuantityAsPieces
                                                    params:
                                                      - name: quantity
                                                        string: ${expectedQuantity}
                                                - executeFunction:
                                                    name: mx.functions.cart.switchProductToWeight
                                                    params:
                                                      - name: direction
                                                        string: down
                                                - executeFunction:
                                                    name: mx.functions.cart.assertProductQuantityAsWeight
                                                    params:
                                                      - name: expectedQuantity
                                                        string: ${expectedWeightQuantity}
                              - log:
                                  message: "Expected Price Assertion (${expectedUnitPrice})..."
                                  color: CYAN
                              - if:
                                  condition: ${expectedUnitPrice} == null
                                  then:
                                    - log:
                                        message: "Price Assertion Skipped (expectedUnitPrice = null)"
                                        color: CYAN
                                  else:
                                    - executeFunction:
                                        name: mx.functions.cart.assertProductUnitPrice
                                        params:
                                          - name: expectedUnitPrice
                                            string: ${expectedUnitPrice}
                              - log:
                                  message: "Expected Subtotal Assertion (${expectedSubtotal})..."
                                  color: CYAN
                              - if:
                                  condition: ${expectedSubtotal} == null
                                  then:
                                    - log:
                                        message: "Subtotal Assertion Skipped (expectedSubtotal = null)"
                                        color: CYAN
                                  else:
                                    # Checking if Product has Multi Savings Promotion for correct subtotal assertion...
                                    - executeFunction:
                                        name: mx.functions.cart.checkIfProductHasMultiSavingsPromotion # <--PARAM--${productName}--RETURNS--${returnedHasMultiSavingsPromotion}-->
                                    - executeFunction:
                                        name: mx.functions.cart.getMultiSavingsDiscountAmount #-PARAMS:--${productName}--{expectedProductTotal} # --RETURNS--${returnedMultiSavingsDiscountAmount}-->
                                        params:
                                          - name: hasMultiSavingsPromotion
                                            string: ${returnedHasMultiSavingsPromotion}
                                          - name: expectedProductTotal
                                            string: ${expectedSubtotal}
                                    - executeFunction:
                                        name: mx.functions.cart.calculateProductSubtotalAfterMultiSavingsPromotion # --RETURNS--${returnedFinalSubtotal}-->
                                        params:
                                          - name: productSubtotal
                                            string: ${expectedSubtotal}
                                          - name: multiSavingsDiscountAmount
                                            string: ${returnedMultiSavingsDiscountAmount}
                                    - executeFunction:
                                        name: mx.functions.cart.assertProductSubtotal # <--[PARAM]--${productName}
                                        params:
                                          - name: expectedSubtotal
                                            string: ${returnedFinalSubtotal}
                                    - log:
                                        message: "Final Product Subtotal: '${returnedFinalSubtotal}'"
                                        color: CYAN
                            else:
                              - if:
                                  condition: ${availability} == 'notAvailable' # for not available products...
                                  then:
                                    - executeFunction:
                                        name: mx.functions.cart.assertProductListedAsOOS # TODO: repair/complete implementation
                                        params:
                                          - name: direction
                                            string: "up"
                                    - executeFunction:
                                        name: mx.functions.cart.assertProductNotListedAsAvailable # TODO: repair/complete implementation
                                        params:
                                          - name: direction
                                            string: "down"
                                  else:
                                    - failTest:
                                        message: "'availability' option not valid: ${availability}"
                else:
                  - failTest:
                      message: "'productListed' option not valid: ${productListed}"
      - log:
          message: "End flow: cart.performProductAssertions"
          color: BLUE

#----------------------------------------------------------------------------------------------------------------------

  # DESCRIPTION: This flow is used to increase a Product's Quantity to its Max Purchase Limit based on its type, and 
  #     returns whatever the final max quantity ended up after the increments.
  #
  #     For Pieces Products: Max Purchase Limit is 99 pieces.
  #     For Weight Products: Max Purchase Limit is 20 kilograms (20,000 grams).
  #     For Dual Products:   Max Purchase Limit is 99 pieces or 20 kilograms (20,000 grams), whatever occurs first.
  #
  #     *   Consider that the supplier store may not have enough stock of the desired product to provide up to 99
  #         pieces or 20 kilograms. So, the Max Purchase Limit may be capped based on the product's stock available.
  #
  #         i.e. There's only 15 pieces of the given Pieces Product in the currently selected supplier store... the
  #         flow will not be able to increase the quantity up to 99 pieces. Instead, it will identify the max stock was
  #         reached and will return 15 as the final max quantity so the developer can use this value, instead of the
  #         original 99 pieces limit, for future assertions or calculations.
  #
  #     *   Additionally, this flow does not perform all the process alone. It determines by the given Product's Type
  #         which sub-flow to execute to perform the process appropriately. The process is slightly different
  #         depending on the Product's Type. See:
  #             - mx.flows.od.cart.increasePiecesProductToMaxQuantity
  #             - mx.flows.od.cart.increaseDualOrWeighableProductToMaxQuantity
  #
  # PARAMS:
  #     ${productName}  [Mandatory]
  #         Name of the Product to increase its quantity.
  #
  #     ${productType}  [Mandatory]
  #         Type of the Product. It's used to determine how to validate the Max Quantity.
  #         Options: [ Pieces | Dual | Weight | Weighable ]
  #
  #     ${productWeightConversionRate} [Conditional]
  #         How much grams are equal to 1 piece of the product. This value is needed only Dual and Weight Products.
  #         For Pieces Products, the flow will just not read this value.
  #
  # RETURNS:
  #     ${returnedMaxQuantity}  The final max quantity that the product was increased to. This might be used for cases
  #         where the supplier store do not have enough stock of that product and the user cannot purchase up to the
  #         original max limits, so the developer can use this value in following assertions and/or calculations.
  #
  # AUTHOR: Sergio Fernandez (vn0t1qt), Francisco Ramirez (vn53vq4)
  - name: mx.flows.od.cart.increaseProductToMaxQuantity
    platform: android
    flow:
      - log:
          message: "Product Name: '${productName}'"
          color: CYAN
      - log:
          message: "Product Type: '${productType}'"
          color: CYAN
      - log:
          message: "Product Weight Conversion Rate: 1 piece equals '${productWeightConversionRate}' grams"
          color: CYAN
      # Check correct ${productType} value...
      - if:
          condition: ${productType} != 'Pieces' && ${productType} != 'Dual' && ${productType} != 'Weight' && ${productType} != 'Weighable'
          then:
            - failTest:
                message: "Flow Failure: Invalid Product Type provided: '${productType}'"
      - log:
          message: "Executing corresponding increase quantity flow based on the product's type..."
          color: GREEN
      # Verify which flow will be triggered based on the product's type...
      - if:
          condition: ${productType} == 'Pieces'
          then:
            # Pieces Product increase quantity trigger...
            - executeFunction:
                name: mx.flows.od.cart.increasePiecesProductToMaxQuantity # <--PARAM--${productName}
      - if:
          condition: ${productType} == 'Dual' || ${productType} == 'Weight' || ${productType} == 'Weighable'
          then:
            # Dual and Weighable Product increase quantity trigger...
            - executeFunction:
                name: mx.flows.od.cart.increaseDualOrWeighableProductToMaxQuantity # <--PARAM--${productName}--${productWeightConversionRate} # pending to complete

      - log:
          message: "End function: flows.od.cart.increaseProductToMaxQuantity"
          color: BLUE

#----------------------------------------------------------------------------------------------------------------------

  # DESCRIPTION: Support sub-flow for 'mx.flows.od.cart.increaseProductToMaxQuantity'. Increases the given Pieces
  #     Product to its Max Purchase Limit (99 pieces), and returns whatever the final max quantity ended up after the
  #     increments.
  #     *   Consider that the supplier store may not have enough stock of the desired product to provide up to 99
  #         pieces. So, the Max Purchase Limit may be capped based on the product's stock available.
  #
  # PARAMS:  ${productName}  [Mandatory]  Name of the Product to increase its quantity.
  #
  # RETURNS:  ${returnedMaxQuantity}  The final max quantity that the product was increased to.
  #
  # AUTHOR: Sergio Fernandez (vn0t1qt), Francisco Ramirez (vn53vq4)
  - name: mx.flows.od.cart.increasePiecesProductToMaxQuantity
    platform: android
    flow:
      - log:
          message: "Product Name: '${productName}'"
          color: CYAN
      # Initial value for max quantity reached flag...
      - storeIn:
          key: productReachedMaxQuantity
          value: false
      # Get the initial value of product in cart...
      - getString:
          attribute: text
          identifier: mx.mappings.cart.collapsedQuantityLabelByProductName # <--PARAM--${productName} get current product Quantity
          storeIn: initialQuantity
      # Clean up the string and extract the current value (integer number only)
      - executeNode:
          file: mx/test/helpers/utils/sanitizeQuantity.js
          args:
            - value: ${initialQuantity}
          getResponse:
            storeIn: initialQuantity

      - storeIn:
          key: expectedQuantity
          value: ${initialQuantity}
      - storeIn:
          key: numberOfClicks
          value: 20
      - storeIn:
          key: numberOfCycles
          value: 5

      # Start a loop of ${numberOfCycles} cycles where the quantity of the product is increased by ${numberOfClicks} increments...
      - loop:
          begin: 0
          end: ${numberOfCycles}
          storeIndex: cycleIndex
          flow:
            - log:
                message: "Cycle ${cycleIndex} of ${numberOfCycles} (${numberOfClicks} clicks)..."
                color: CYAN
            - arithmetic:
                expression: ${expectedQuantity} + ${numberOfClicks}
                storeIn: expectedQuantity
            - try:
                flow:
                 # Click the increase button ${numberOfClicks} times...
                   - click:
                       identifier: mx.mappings.slp.increaseQuantityButton # <--PARAM--${productName}
                       numberOfClicks: ${numberOfClicks} 
                       waitBetweenClicks: 1
                catch:
                  flow:
                    # increase button becomes not clickable, so an exception is thrown when trying to click the button.
                    # If the exception happened, log a message to notify the user.
                    # The TC should not fail, there's just no need to try to click the increase button anymore.
                    - log:
                        message: "Increase button not clickable anymore, process will continue."
                        color: CYAN

            - sleep:
                duration: 5000

            # The loop to increment quantity ${numberOfClicks} times might have finished because of 2 possible cases:
            # - the "max stock" in the supplier store was reached, or
            # - the loop incremented the ${numberOfClicks} times (in which case we may have reached the "max quantity limit" or not yet)
            - getString:
                attribute: text
                identifier: mx.mappings.cart.collapsedQuantityLabelByProductName # <--PARAM--${productName} get current product Quantity
                storeIn: currentQuantity
            - log:
                message: "Current Quantity: ${currentQuantity}"
                color: GREEN

            # This function returns a boolean value if quantity reaches the max value or not.
            - executeNode:
                file: mx/test/helpers/utils/stringContainsAny.js
                args:
                  - value: ${currentQuantity}
                  - value: "Máx. 99 | Max. 99 | Max.99 | Máx.99 | 99" 
                getResponse:
                  storeIn: productReachedMaxQuantity

            - log:
                message: "Checking if Max Quantity Limit of 99 was reached..."
                color: GREEN
            - if:
                condition: ${productReachedMaxQuantity} == true
                then:
                  - log:
                      message: "Max Quantity Limit of 99 pieces was reached!!"
                      color: CYAN
                  - break: true
                else:
                  - log:
                      message: "Max Quantity Limit of 99 pieces not reached yet"
                      color: GREEN
                  - log:
                      message: "Checking if Max Product Stock was reached..."
                      color: GREEN
                  - if:
                      condition: ${currentQuantity} < ${expectedQuantity}
                      then:
                        - log: 
                            message: "Max Product Stock was reached!!"
                            color: CYAN   
                        - storeIn:
                            key: productReachedMaxQuantity
                            value: true
                        - break: true
                      else:
                        - log: 
                            message: "Max Product Stock not reached yet"
                            color: GREEN
                
      # Once the external cycle loop finished, either because a break or all the cycles were executed...
      # Check whether the max quantity reached flag was set to true or false and return the max quantity reached...
      - if:
          condition: ${productReachedMaxQuantity} == true
          then:
            # If equals to true, collect the current displayed quantity and set it on the returned value for the developer to use it if necessary...
            - getString:
                attribute: text
                identifier: mx.mappings.cart.collapsedQuantityLabelByProductName # <--PARAM--${productName}
                storeIn: returnedMaxQuantity
            - executeNode:
                file: mx/test/helpers/utils/sanitizeQuantity.js
                args:
                  - value: ${returnedMaxQuantity}
                getResponse:
                  storeIn: returnedMaxQuantity
            - log:
                message: "Max Quantity Got: '${returnedMaxQuantity}' pieces."
                color: CYAN
          else:
            # If equals to false, fail the test case...
            - failTest:
                message: "Products Max Quantity was never reached in ${numberOfCycles} cycles of ${numberOfClicks} increments."
      - log:
          message: "End function: flows.od.cart.increasePiecesProductToMaxQuantity"
          color: BLUE
  
  #----------------------------------------------------------------------------------------------------------------------

  # DESCRIPTION: Support sub-flow for 'mx.flows.od.cart.increaseProductToMaxQuantity'. Increases the given Dual or
  #     Weighable Product to its Max Quantity Limit, and returns the Final Max Quantity.
  #
  #     *   See documentation of 'mx.flows.od.cart.increaseProductToMaxQuantity' for additional details.
  #
  # PARAMS:  ${productName}                  [Mandatory]  Name of the Product to increase its quantity.
  #          ${productType}                  [Mandatory]  Type of the Product. Options: [ Dual | Weight | Weighable ]
  #          ${productWeightConversionRate}  [Mandatory]  How many grams are equal to 1 piece of the product.
  #
  # RETURNS:  ${returnedMaxQuantity}  The Final Max Quantity that the product was increased to.
  #
  # AUTHOR: Sergio Fernandez (vn0t1qt), Francisco Ramirez (vn53vq4)
  - name: mx.flows.od.cart.increaseDualOrWeighableProductToMaxQuantity
    platform: android
    flow:

       # Calculate the max purchase limit based on product's weight conversion rate...
      - executeNode:
          file: mx/test/helpers/utils/mathDivisionWorkaround.js
          args:
            - value: 20000
            - value: ${productWeightConversionRate}
            - value: true
          getResponse:
            storeIn: maxPurchaseLimitBasedOnWeightConversionRate # Gets only the integer part of the division.
      
      # Calculate the max purchase limit based on the weight conversion rate    
      - arithmetic:
          expression: ${maxPurchaseLimitBasedOnWeightConversionRate} * ${productWeightConversionRate}
          asInt: true
          storeIn: maxPurchaseLimitBasedOnWeightConversionRate
      
      - log:
          message: "Product Name: '${productName}'"
          color: CYAN
      - log:
          message: "Product Type: '${productType}'"
          color: CYAN
      - log:
          message: "Product Weight Conversion Rate: '${productWeightConversionRate}' (grams)"
          color: CYAN
      - log:
          message: "Max Purchase Limit: '20000' (grams) (if enough stock available)"
          color: CYAN
      - log:
          message: "Max Purchase Limit (based on Weight Conversion Rate): '${maxPurchaseLimitBasedOnWeightConversionRate}' (grams) (if enough stock available)"
          color: CYAN
      
      # Validation of the correct product type...
      - if:
          condition: ${productType} == 'Pieces'
          then:
            - failTest:
                message: "Invalid Product Type: '${productType}' not accepted for this function."
      
      # Calculate the number of increments that is going to be used in the loop based on the productWeightConversionRate...
      - executeNode:
          file: mx/test/helpers/utils/mathDivisionWorkaround.js
          args:
            - value: 4000
            - value: ${productWeightConversionRate}
            - value: true
          getResponse:
            storeIn: numberOfIncrements # Gets only the integer part of the division.

      # Increment numberOfIncrements by 1 (to always compensate the decimals in case of the calculation had decimals originally)...
      - arithmetic:
          expression: ${numberOfIncrements} + 1
          asInt: true
          storeIn: numberOfIncrements

      # Initial value for productReachedMaxQuantity flag to determine whether the max quantity was reached...
      - storeIn:
          key: productReachedMaxQuantity
          value: false

      # Get the origignal quantity
      - if:
          identifier:
            present:
              - identifier: mx.mappings.department-l3.weightOption # <--PARAM--${productName} # reusing mapping.
          then:
            - click:
                identifier: mx.mappings.department-l3.weightOption # <--PARAM--${productName} # reusing mapping.

      - getString:
            attribute: text
            identifier: mx.mappings.cart.collapsedQuantityLabelByProductName # <--PARAM--${productName} get current product Quantity
            storeIn: originalQuantity
      - executeNode:
          file: mx/test/helpers/utils/sanitizeQuantity.js
          args:
            - value: ${originalQuantity} 
          getResponse:
              storeIn: originalQuantity
      - log:
          message: "The original Quantity has: ${originalQuantity}"
          color: GREEN
      
      # Start a loop of 5 cycles where the quantity of the product is increased by a calculated number of increments...
      # (i.e. 5 cycles of 80 increments (for a product which weight is 50 g) = 20,000+ grams incremented)           
      - loop:
          begin: 0
          end: 5
          storeIndex: cycleIndex
          flow:
            # Switch to grams in case the product is a Dual product...
            - if:
                condition: ${cycleIndex} == 0 && ${productType} == 'Dual'
                then:
                    - click:
                        identifier: mx.mappings.department-l3.weightOption # <--PARAM--${productName} # re-using mapping.
            # Increment the quantity as many times as 'numberOfIncrements'...
            - try:
                flow:
                  # If the Max Available Stock is reached, a pop-up is shown and the increase button becomes not clickable,
                  # so an exception is thrown when trying to click the button.
                  - click:
                      identifier: mx.mappings.slp.increaseQuantityButton # <--PARAM--${productName}
                      numberOfClicks: ${numberOfIncrements}
                      waitBetweenClicks: 1
                catch:
                  flow:
                    # If the exception happened, just log a message, the TC should't fail...
                    - log:
                        message: "Increase button not clickable anymore, process will continue."
                        color: CYAN
            - sleep:
                duration: 5000
            # The loop to increment quantity ${numberOfClicks} times might have finished because of 2 possible cases:
            # - the "max stock" in the supplier store was reached, or
            # - the loop incremented the ${numberOfClicks} times (in which case we may have reached the "max quantity limit" or not yet)

                
      # At this moment there should be 2 cases that might have happened...
      # 1) The Max Available Stock might have been reached (because the supplier store does not have enough stock to supply the Max Quantity Limit), or...
      # 2) All the increments were done successfully (in which case we still don't know if the Max Quantity Limit was reached or not)
      - getString:
            attribute: text
            identifier: mx.mappings.cart.collapsedQuantityLabelByProductName # <--PARAM--${productName} get current product Quantity
            storeIn: returnedQuantity

      - executeNode:
          file: mx/test/helpers/utils/sanitizeQuantity.js
          args:
            - value: ${returnedQuantity} 
          getResponse:
              storeIn: returnedQuantity
      - log:
          message: "Returned Quantity: ${returnedQuantity}"
          color: GREEN

      - log:
          message: "Checking if Max Quantity Limit was reached..."
          color: GREEN
      - if:
          condition: ${returnedQuantity} == ${maxPurchaseLimitBasedOnWeightConversionRate} 
          then:
          - log:
              message: "Product's Max Quantity was reached!!!"
              color: CYAN
          - storeIn:
              key: productReachedMaxQuantity
              value: true
          - getString:
              attribute: text
              identifier: mx.mappings.cart.collapsedQuantityLabelByProductName # <--PARAM--${productName}
              storeIn: returnedMaxQuantity
          - executeNode:
              file: mx/test/helpers/utils/sanitizeQuantity.js
              args:
                  - value: ${returnedMaxQuantity}
              getResponse:
                  storeIn: returnedMaxQuantity
          - log:
               message: "Max Quantity Got: '${returnedMaxQuantity}' g."
               color: CYAN
          else:
            - log:
                message: "Checking for Max Stock..."
                color: GREEN
            - if:
                condition: ${returnedQuantity} > ${originalQuantity} && ${returnedQuantity} < ${maxPurchaseLimitBasedOnWeightConversionRate}  
                then: 
                  - storeIn:
                      key: maxStockScenario
                      value: true
                  - log:
                      message: "Max Stock was reached!"
                      color: GREEN
                  - getString:
                        attribute: text
                        identifier: mx.mappings.cart.collapsedQuantityLabelByProductName # <--PARAM--${productName}
                        storeIn: returnedMaxStock
                  - executeNode:
                      file: mx/test/helpers/utils/sanitizeQuantity.js
                      args:
                          - value: ${returnedMaxStock}
                      getResponse:
                          storeIn: returnedMaxStock
                  - log: 
                      message: "The Max stock was: ${returnedMaxStock} g."
                      color: CYAN
                else:
                    - failTest:
                        message: "Product's Max Quantity was never reached in ${numberOfCycles} cycles of ${numberOfClicks} increments."
      - log:
          message: "End function: flows.od.cart.increaseDualOrWeighableProductToMaxQuantity"
          color: BLUE

  #----------------------------------------------------------------------------------------------------------------------

  # DESCRIPTION: Performs all the following assertions for the given product name.
  #   - Product Listed:       Asserts the product is listed on Cart list.
  #   - Expected Quantity:    Whether the displayed expected quantity is correct. This assertion is performed based in the Product Type.
  #   - Expected Unit Price:  Whether the displayed price (unit price) is correct.
  #   - Expected Subtotal:    Whether the displayed subtotal is correct.
  #
  # PARAMS:  ${productName}             [Mandatory]  Name of the product to perform assertions for.
  #          ${productType}             [Optional]   Set to 'null' to prevent flow from getting the product's type on Cart Page.
  #          ${expectedQuantity}        [Mandatory]  Expected quantity the product should show. Options: [ <numeric value> | null ]
  #                                                    If option is a numeric value, the method will assert that as the expected quantity the product should display.
  #                                                    If option is 'null', this assertion will be skipped.
  #          ${expectedWeightQuantity}  [Mandatory]  Expected weight quantity the product should should. Options: [ <numeric value> ]
  #                                                    It is needed only when the product is 'Weight' or 'Dual'. For 'Pieces' products it is not; it can be empty value or 'null'.
  #          ${expectedUnitPrice}       [Mandatory]  Expected price the product should show. Options: [ <numeric value> | null ]
  #                                                    If option is a numeric value, the method will assert that as the expected price the product should display.
  #                                                    If option is 'null', this assertion will be skipped.
  #          ${expectedSubtotal}        [Mandatory]  Expected sub-total the product should show. Options: [ <numeric value> | null ]
  #                                                    If option is a numeric value, the method will assert that as the expected subtotal the product should display.
  #                                                    If option is 'null', this assertion will be skipped.
  # RETURNS: ${returnedFinalSubtotal}   This is the updated product subtotal that will be calculated in case a product with Multi-Savings promotion was found in cart.
  # EDITOR: Osmar Juárez (vn56dce)
  - name: mx.flows.od.cart.quickPerformProductAssertions
    platform: android
    flow:
      - log:
          message: "Product Name: ${productName}"
          color: CYAN
      - executeFunction:
          name: mx.functions.cart.assertProductListed # <--[PARAM]--${productName}
      # Expected Quantity Assertion...
      - log:
          message: "Expected Quantity Assertion (Pieces: ${expectedQuantity} | Weight: ${expectedWeightQuantity})..."
          color: CYAN
      - if:
          condition: ${productType} != null
          then:
            # Check correct ${productType} value...
            - if:
                condition: ${productType} != 'Pieces' && ${productType} != 'Dual' && ${productType} != 'Weight' && ${productType} != 'Weighable'
                then:
                  - failTest:
                      message: "Flow Failure: Invalid Product Type provided: '${productType}'"
            - log:
                message: "Product Type has been provided: '${productType}', no need to get current Product's type..."
                color: CYAN
          else:
            - log:
                message: "Product Type NOT provided. Retrieving current Product's Type..."
                color: CYAN
            - executeFunction:
                name: mx.functions.cart.getProductType # <--[PARAM]--${productName}--[RETURNS]--${returnedProductType}-->
            - storeIn:
                key: productType
                value: ${returnedProductType}
      - if:
          condition: ${expectedQuantity} == null
          then:
            - log:
                message: "Quantity Assertion Skipped (expectedQuantity = null)"
                color: CYAN
          else:
            - if:
                condition: ${productType} == 'Pieces' # for 'Pieces' products...
                then:
                  - executeFunction:
                      name: mx.functions.cart.assertProductQuantityAsPieces # <--[PARAM]--${productName}
                      params:
                        - name: expectedQuantity
                          string: ${expectedQuantity}
            - if:
                condition: ${productType} == 'Weighable' || ${productType} == 'Weight' # for 'Weight' products...
                then:
                  - executeFunction:
                      name: mx.functions.cart.assertProductQuantityAsWeight # <--[PARAM]--${productName}
                      params:
                        - name: expectedQuantity
                          string: ${expectedWeightQuantity}
            - if:
                condition: ${productType} == 'Dual' # for 'Dual' products...
                then:
                  - executeFunction:
                      name: mx.functions.cart.switchProductToPieces # <--[PARAM]--${productName}
                      params:
                        - name: direction
                          string: down
                  - sleep:
                      duration: 3000
                  - executeFunction:
                      name: mx.functions.cart.assertProductQuantityAsPieces # <--[PARAM]--${productName}
                      params:
                        - name: expectedQuantity
                          string: ${expectedQuantity}
                  - executeFunction:
                      name: mx.functions.cart.switchProductToWeight # <--[PARAM]--${productName}
                      params:
                        - name: direction
                          string: down
                  - executeFunction:
                      name: mx.functions.cart.assertProductQuantityAsWeight # <--[PARAM]--${productName}
                      params:
                        - name: expectedQuantity
                          string: ${expectedWeightQuantity}
      # Product Unit Price Assertion...
      - log:
          message: "Expected Unit Price Assertion (${expectedUnitPrice})..."
          color: CYAN
      - if:
          condition: ${expectedUnitPrice} == null
          then:
            - log:
                message: "Unit Price Assertion Skipped (expectedUnitPrice = null)"
                color: CYAN
          else:
            - executeFunction:
                name: mx.functions.cart.assertProductUnitPrice # <--[PARAM]--${productName}
                params:
                  - name: expectedUnitPrice
                    string: ${expectedUnitPrice}
      # Product Subtotal Price Assertion...
      - log:
          message: "Expected Subtotal Assertion (${expectedSubtotal})..."
          color: CYAN
      - if:
          condition: ${expectedSubtotal} == null
          then:
            - log:
                message: "Subtotal Assertion Skipped (expectedSubtotal = null)"
                color: CYAN
          else:
            # Checking if Product has Multi Savings Promotion for correct subtotal assertion...
            - executeFunction:
                name: mx.functions.cart.checkIfProductHasMultiSavingsPromotion # <--PARAM--${productName}--RETURNS--${returnedHasMultiSavingsPromotion}-->
             # if product with multisavings has no extra discount proceed to get multisaving discount ammount as regular 
            - if:
                condition: ${returnedHasMultiSavingsPromotion} == true && ${expectedOriginalPrice} == null
                then:
                  - executeFunction:
                      name: mx.functions.cart.getMultiSavingsDiscountAmount #-PARAMS:--${productName}--{expectedProductTotal} # --RETURNS--${returnedMultiSavingsDiscountAmount}-->
                      params:
                        - name: hasMultiSavingsPromotion
                          string: ${returnedHasMultiSavingsPromotion}
                        - name: expectedProductTotal
                          string: ${expectedSubtotal}
                  - executeFunction:
                      name: mx.functions.cart.calculateProductSubtotalAfterMultiSavingsPromotion # --RETURNS--${returnedFinalSubtotal}-->
                      params:
                        - name: productSubtotal
                          string: ${expectedSubtotal}
                        - name: multiSavingsDiscountAmount
                          string: ${returnedMultiSavingsDiscountAmount}
                else:
                  - storeIn:
                      key: returnedFinalSubtotal
                      value: ${expectedSubtotal}
            - executeFunction:
                name: mx.functions.cart.assertProductSubtotal # <--[PARAM]--${productName}
                params:
                  - name: expectedSubtotal
                    string: ${returnedFinalSubtotal}
            - log:
                message: "Final Product Subtotal: '${returnedFinalSubtotal}'"
                color: CYAN
      - log:
          message: "End flow: cart.quickPerformProductAssertions"
          color: BLUE

  #--------------------------------------------------------------------------------------------------------------------
 
  # Description:
  #   This method asserts the subtotal before and after discounts, it assumes there are discounts in the cart.
  # PARAMS:
  #   ${cartSubtotal}  [Mandatory]  Cart Subtotal Amount. Do not change this param name.
  #                                   If cart has discounts, cart subtotal should be equal to all products subtotals after discounts.
  #                                   If no discounts are found, cart subtotal should be equal to all products subtotals (without any discounts).
  # AUTHOR: Rodrigo Pacheco (vn53p0i)
  - name: mx.flows.od.cart.assertSubtotalsIfCartHasDiscounts
    platform: android
    flow:
      - executeFunction:
          name: mx.functions.cart.assertSubtotalAfterDiscount
          params:
            - name: expectedSubtotalAfterDiscount
              string: ${cartSubtotal}
      # Retrieving displayed discount value...
      - executeFunction:
          name: mx.functions.cart.getCartDiscount #--[RETURNS]--${returnedCartDiscount}-->
      # Calculating Subtotal value before Discount...
      - log:
          message: Calculating Subtotal value before Discount...
          color: CYAN
      - arithmetic:
          expression: ${cartSubtotal} + (${returnedCartDiscount} * (-1)) # This is because the discount value contains the minus sign.
          numberOfDecimalPlaces: 2
          storeIn: returnedCartSubtotalBeforeDiscount
      - log:
          message: "Calculated Subtotal value before discount got: '${returnedCartSubtotalBeforeDiscount}'"
          color: CYAN
      - executeFunction:
          name: mx.functions.cart.assertSubtotal # This function always runs the validation on the subtotal value before discount (if any).
          params:
            - name: expectedSubtotal
              string: ${returnedCartSubtotalBeforeDiscount}
      - log:
          message: "End function: cart.assertSubtotalsIfCartHasDiscounts"
          color: BLUE
